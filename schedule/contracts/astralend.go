// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package astralend

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// AstralendMetaData contains all meta data concerning the Astralend contract.
var AstralendMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multiSignature\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimLend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"DepositBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyBorrowWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyLendWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"RefundBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"RefundLend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newLendFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBorrowFee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFeeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"SetFeeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMinAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMinAmount\",\"type\":\"uint256\"}],\"name\":\"SetMinAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSwapAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSwapAddress\",\"type\":\"address\"}],\"name\":\"SetSwapRouterAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"beforeState\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"afterState\",\"type\":\"uint256\"}],\"name\":\"StateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromCoin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toValue\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLend\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"borrowFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mortgageRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_jpCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_autoLiquidateThreshold\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositLend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"addresspayable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contractIAstraLendOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolBaseInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lendSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mortgageRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"enumAstraLendPool.PoolState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"contractDebtToken\",\"name\":\"spCoin\",\"type\":\"address\"},{\"internalType\":\"contractDebtToken\",\"name\":\"jpCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"autoLiquidateThreshold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolDataInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"settleAmountLend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleAmountBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishAmountLend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishAmountBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationAmounLend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationAmounBorrow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"refundLend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userBorrowInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasNoRefund\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasNoClaim\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userLendInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasNoRefund\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasNoClaim\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080604052346100335761001d61001461014f565b9291909161042e565b610025610038565b6126be61069982396126be90f35b61003e565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061006a90610042565b810190811060018060401b0382111761008257604052565b61004c565b9061009a610093610038565b9283610060565b565b5f80fd5b60018060a01b031690565b6100b4906100a0565b90565b6100c0816100ab565b036100c757565b5f80fd5b905051906100d8826100b7565b565b6100e3906100a0565b90565b6100ef816100da565b036100f657565b5f80fd5b90505190610107826100e6565b565b60808183031261014a5761011f825f83016100cb565b9261014761013084602085016100cb565b9361013e81604086016100fa565b936060016100cb565b90565b61009c565b61016d612d578038038061016281610087565b928339810190610109565b90919293565b5f1b90565b9061018460ff91610173565b9181191691161790565b151590565b61019c9061018e565b90565b90565b906101b76101b26101be92610193565b61019f565b8254610178565b9055565b906101ce5f1991610173565b9181191691161790565b90565b90565b90565b6101f56101f06101fa926101d8565b6101de565b6101db565b90565b90565b9061021561021061021c926101e1565b6101fd565b82546101c2565b9055565b90565b61023761023261023c92610220565b6101de565b6100a0565b90565b61024890610223565b90565b60209181520190565b5f7f4973207a65726f20616464726573730000000000000000000000000000000000910152565b610288600f60209261024b565b61029181610254565b0190565b6102aa9060208101905f81830391015261027b565b90565b156102b457565b6102bc610038565b62461bcd60e51b8152806102d260048201610295565b0390fd5b6102ea6102e56102ef926100a0565b6101de565b6100a0565b90565b6102fb906102d6565b90565b610307906102f2565b90565b610313906102d6565b90565b61031f9061030a565b90565b9061033360018060a01b0391610173565b9181191691161790565b6103469061030a565b90565b90565b9061036161035c6103689261033d565b610349565b8254610322565b9055565b610375906102f2565b90565b90565b9061039061038b6103979261036c565b610378565b8254610322565b9055565b6103a4906102d6565b90565b6103b09061039b565b90565b90565b906103cb6103c66103d2926103a7565b6103b3565b8254610322565b9055565b6103ea6103e56103ef92610220565b6101de565b6101db565b90565b61040661040161040b926101db565b6101de565b6101db565b90565b9061042361041e61042a926103f2565b6101fd565b82546101c2565b9055565b906104df6104d86104e6936104456104ed97610604565b6104505f60016101a2565b61046468056bc75e2d631000006002610200565b6104898161048261047c6104775f61023f565b6100ab565b916100ab565b14156102ad565b6104ae846104a76104a161049c5f61023f565b6100ab565b916100ab565b14156102ad565b6104d3866104cc6104c66104c15f61023f565b6100ab565b916102fe565b14156102ad565b610316565b600361034c565b600461037b565b60056103b6565b6105006104f95f6103d6565b600661040e565b61051361050c5f6103d6565b600761040e565b565b5f7f6d756c74695369676e617475726541646472657373206973207a65726f000000910152565b610549601d60209261024b565b61055281610515565b0190565b61056b9060208101905f81830391015261053c565b90565b1561057557565b61057d610038565b62461bcd60e51b81528061059360048201610556565b0390fd5b5f1c90565b6105a86105ad91610597565b6103f2565b90565b6105d97f8dddb57468cf5338ee155397ad1400a7a564308824f517d20a8a7c516523bb4761059c565b90565b6105e5906102d6565b90565b6105fc6105f7610601926100a0565b6101de565b6101db565b90565b61065490610610610682565b6106358161062e6106286106235f61023f565b6100ab565b916100ab565b141561056e565b61064e6106496106436105b0565b926105dc565b6105e8565b90610695565b565b90565b61066d61066861067292610656565b6101de565b6101db565b90565b61067f6001610659565b90565b61069361068d610675565b5f61040e565b565b5556fe60806040526004361015610013575b610d96565b61001d5f3561010c565b8063081e3eda146101075780630d6abfc1146101025780633c9fadc3146100fd57806341275358146100f8578063459b911c146100f35780634aea0aec146100ee57806361a552dc146100e95780637dc0d1d0146100e457806390590da0146100df578063981b48a6146100da5780639b2cb5d8146100d5578063bb176a64146100d0578063c31c9c07146100cb578063e626648a146100c65763eec8d5060361000e57610d63565b610d2e565b610cea565b610c66565b610bbd565b610b72565b610a48565b6109e6565b610943565b6108c4565b61084f565b610778565b6106cc565b6104fd565b610154565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261012a57565b61011c565b90565b61013b9061012f565b9052565b9190610152905f60208501940190610132565b565b3461018457610164366004610120565b61018061016f610d9e565b610177610112565b9182918261013f565b0390f35b610118565b6101928161012f565b0361019957565b5f80fd5b905035906101aa82610189565b565b906020828203126101c5576101c2915f0161019d565b90565b61011c565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6101f4816101de565b82101561020e57610206600c916101e2565b910201905f90565b6101ca565b5f1c90565b90565b61022761022c91610213565b610218565b90565b610239905461021b565b90565b60018060a01b031690565b61025361025891610213565b61023c565b90565b6102659054610247565b90565b60a01c90565b60ff1690565b61028061028591610268565b61026e565b90565b6102929054610274565b90565b60018060a01b031690565b6102ac6102b191610213565b610295565b90565b6102be90546102a0565b90565b6008906102cd826101de565b811015610387576102dd916101eb565b506102e95f820161022f565b916102f66001830161022f565b916103036002820161022f565b916103106003830161022f565b9161031d6004820161022f565b9161032a6005830161022f565b916103376006820161022f565b916103446007830161025b565b916103516008820161025b565b9161035e60088301610288565b9161036b600982016102b4565b91610384600b61037d600a85016102b4565b930161022f565b90565b5f80fd5b60018060a01b031690565b61039f9061038b565b90565b6103ab90610396565b9052565b634e487b7160e01b5f52602160045260245ffd5b600511156103cd57565b6103af565b906103dc826103c3565b565b6103e7906103d2565b90565b6103f3906103de565b9052565b90565b61040e6104096104139261038b565b6103f7565b61038b565b90565b61041f906103fa565b90565b61042b90610416565b90565b61043790610422565b9052565b9a98969492909d9c9b99979593916101a08c019e5f8d0161045b91610132565b60208c0161046891610132565b60408b0161047591610132565b60608a0161048291610132565b6080890161048f91610132565b60a0880161049c91610132565b60c087016104a991610132565b60e086016104b6916103a2565b61010085016104c4916103a2565b61012084016104d2916103ea565b61014083016104e09161042e565b61016082016104ee9161042e565b610180016104fb91610132565b565b3461053d576105396105186105133660046101ac565b6102c1565b996105309d9b9d999199989298979397969496610112565b9d8e9d8e61043b565b0390f35b610118565b61054b81610396565b0361055257565b5f80fd5b9050359061056382610542565b565b919060408382031261058d578061058161058a925f8601610556565b9360200161019d565b90565b61011c565b61059b90610416565b90565b906105a890610592565b5f5260205260405f2090565b6105c86105c36105cd9261012f565b6103f7565b61012f565b90565b906105da906105b4565b5f5260205260405f2090565b60ff1690565b6105f86105fd91610213565b6105e6565b90565b61060a90546105ec565b90565b60081c90565b61061f6106249161060d565b6105e6565b90565b6106319054610613565b90565b9061064361064892600a61059e565b6105d0565b906106545f830161022f565b916106616001820161022f565b916106796002610672818501610600565b9301610627565b90565b151590565b61068a9061067c565b9052565b6106c36106ca946106b96060949897956106af608086019a5f870190610132565b6020850190610132565b6040830190610681565b0190610681565b565b34610701576106fd6106e86106e2366004610565565b90610634565b906106f4949294610112565b9485948561068e565b0390f35b610118565b1c90565b60018060a01b031690565b61072590600861072a9302610706565b61070a565b90565b906107389154610715565b90565b61074760055f9061072d565b90565b6107539061038b565b90565b61075f9061074a565b9052565b9190610776905f60208501940190610756565b565b346107a857610788366004610120565b6107a461079361073b565b61079b610112565b91829182610763565b0390f35b610118565b61014081830312610845576107c4825f830161019d565b926107d2836020840161019d565b926107e0816040850161019d565b926107ee826060830161019d565b926107fc836080840161019d565b9261080a8160a08501610556565b926108188260c08301610556565b926108426108298460e08501610556565b93610838816101008601610556565b936101200161019d565b90565b61011c565b5f0190565b3461088a576108746108623660046107ad565b9897909796919695929594939461167b565b61087c610112565b806108868161084a565b0390f35b610118565b61089f9060086108a49302610706565b610218565b90565b906108b2915461088f565b90565b6108c160065f906108a7565b90565b346108f4576108d4366004610120565b6108f06108df6108b5565b6108e7610112565b9182918261013f565b0390f35b610118565b61090990600861090e9302610706565b6105e6565b90565b9061091c91546108f9565b90565b61092b60015f90610911565b90565b9190610941905f60208501940190610681565b565b3461097357610953366004610120565b61096f61095e61091f565b610966610112565b9182918261092e565b0390f35b610118565b60018060a01b031690565b6109939060086109989302610706565b610978565b90565b906109a69154610983565b90565b6109b560035f9061099b565b90565b6109c190610416565b90565b6109cd906109b8565b9052565b91906109e4905f602085019401906109c4565b565b34610a16576109f6366004610120565b610a12610a016109a9565b610a09610112565b918291826109d1565b0390f35b610118565b9190604083820312610a435780610a37610a40925f860161019d565b9360200161019d565b90565b61011c565b610a5c610a56366004610a1b565b90611d92565b610a64610112565b80610a6e8161084a565b0390f35b5490565b5f5260205f2090565b610a8881610a72565b821015610aa257610a9a600691610a76565b910201905f90565b6101ca565b600990610ab382610a72565b811015610b1357610ac391610a7f565b5090610ad05f830161022f565b91610add6001820161022f565b91610aea6002830161022f565b91610af76003820161022f565b91610b106005610b096004850161022f565b930161022f565b90565b5f80fd5b9194610b5f610b6992989795610b5560a096610b4b610b709a610b4160c08a019e5f8b0190610132565b6020890190610132565b6040870190610132565b6060850190610132565b6080830190610132565b0190610132565b565b34610ba957610ba5610b8d610b883660046101ac565b610aa7565b92610b9c969496929192610112565b96879687610b17565b0390f35b610118565b610bba60025f906108a7565b90565b34610bed57610bcd366004610120565b610be9610bd8610bae565b610be0610112565b9182918261013f565b0390f35b610118565b90610bfc90610592565b5f5260205260405f2090565b90610c12906105b4565b5f5260205260405f2090565b90610c2d610c3292600b610bf2565b610c08565b90610c3e5f830161022f565b91610c4b6001820161022f565b91610c636002610c5c818501610600565b9301610627565b90565b34610c9b57610c97610c82610c7c366004610565565b90610c1e565b90610c8e949294610112565b9485948561068e565b0390f35b610118565b610cb0906008610cb59302610706565b61023c565b90565b90610cc39154610ca0565b90565b610cd260045f90610cb8565b90565b9190610ce8905f602085019401906103a2565b565b34610d1a57610cfa366004610120565b610d16610d05610cc6565b610d0d610112565b91829182610cd5565b0390f35b610118565b610d2b60075f906108a7565b90565b34610d5e57610d3e366004610120565b610d5a610d49610d1f565b610d51610112565b9182918261013f565b0390f35b610118565b34610d9157610d7b610d763660046101ac565b6121d7565b610d83610112565b80610d8d8161084a565b0390f35b610118565b5f80fd5b5f90565b610da6610d9a565b50610db160086101de565b90565b90610dce999897969594939291610dc96123ab565b611445565b565b60209181520190565b60207f6574746c652074696d6500000000000000000000000000000000000000000000917f637265617465506f6f6c3a656e642074696d65206772617465207468616e20735f8201520152565b610e33602a604092610dd0565b610e3c81610dd9565b0190565b610e559060208101905f818303910152610e26565b90565b15610e5f57565b610e67610112565b62461bcd60e51b815280610e7d60048201610e40565b0390fd5b90565b610e98610e93610e9d92610e81565b6103f7565b61038b565b90565b610ea990610e84565b90565b5f7f637265617465506f6f6c3a6973207a65726f2061646472657373000000000000910152565b610ee0601a602092610dd0565b610ee981610eac565b0190565b610f029060208101905f818303910152610ed3565b90565b15610f0c57565b610f14610112565b62461bcd60e51b815280610f2a60048201610eed565b0390fd5b610f37906103fa565b90565b610f4390610f2e565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90610f6e90610f46565b810190811067ffffffffffffffff821117610f8857604052565b610f50565b90610fa0610f99610112565b9283610f64565b565b610fad6101a0610f8d565b90565b90610fba9061012f565b9052565b610fd2610fcd610fd792610e81565b6103f7565b61012f565b90565b90610fe490610396565b9052565b90610ff2906103d2565b9052565b610fff90610396565b90565b9061100c90610ff6565b9052565b90565b5f5260205f2090565b5490565b6110298161101c565b8210156110435761103b600c91611013565b910201905f90565b6101ca565b634e487b7160e01b5f525f60045260245ffd5b611065905161012f565b90565b5f1b90565b906110795f1991611068565b9181191691161790565b90565b9061109b6110966110a2926105b4565b611083565b825461106d565b9055565b6110b09051610396565b90565b906110c460018060a01b0391611068565b9181191691161790565b90565b906110e66110e16110ed92610592565b6110ce565b82546110b3565b9055565b6110fb90516103d2565b90565b60a01b90565b9061111360ff60a01b916110fe565b9181191691161790565b611126906103d2565b90565b90565b9061114161113c6111489261111d565b611129565b8254611104565b9055565b6111569051610ff6565b90565b61116290610f2e565b90565b90565b9061117d61117861118492611159565b611165565b82546110b3565b9055565b906112cb610180600b6112d1946111ac5f82016111a65f880161105b565b90611086565b6111c5600182016111bf6020880161105b565b90611086565b6111de600282016111d86040880161105b565b90611086565b6111f7600382016111f16060880161105b565b90611086565b6112106004820161120a6080880161105b565b90611086565b6112296005820161122360a0880161105b565b90611086565b6112426006820161123c60c0880161105b565b90611086565b61125b6007820161125560e088016110a6565b906110d1565b6112756008820161126f61010088016110a6565b906110d1565b61128f6008820161128961012088016110f1565b9061112c565b6112a9600982016112a3610140880161114c565b90611168565b6112c3600a82016112bd610160880161114c565b90611168565b01920161105b565b90611086565b565b91906112e4576112e291611188565b565b611048565b9081549168010000000000000000831015611319578261131191600161131795018155611020565b906112d3565b565b610f50565b90565b61132b60c0610f8d565b90565b5f5260205f2090565b5490565b61134481611337565b82101561135e5761135660069161132e565b910201905f90565b6101ca565b906113f260a060056113f8946113865f82016113805f880161105b565b90611086565b61139f600182016113996020880161105b565b90611086565b6113b8600282016113b26040880161105b565b90611086565b6113d1600382016113cb6060880161105b565b90611086565b6113ea600482016113e46080880161105b565b90611086565b01920161105b565b90611086565b565b919061140b5761140991611363565b565b611048565b9081549168010000000000000000831015611440578261143891600161143e9501815561133b565b906113fa565b565b610f50565b98969491979592939098898161145a9061012f565b906114649061012f565b1161146e90610e58565b855f61147990610ea0565b61148290610396565b9061148c90610396565b141561149790610f05565b865f6114a290610ea0565b6114ab90610396565b906114b590610396565b14156114c090610f05565b9897935f905f929394955f976114d590610f3a565b986114df90610f3a565b999a6114e9610fa2565b9c5f8e01906114f791610fb0565b60208d019061150591610fb0565b60408c019061151391610fb0565b60608b019061152191610fb0565b61152a90610fbe565b60808a019061153891610fb0565b61154190610fbe565b60a089019061154f91610fb0565b60c088019061155d91610fb0565b60e087019061156b91610fda565b61010086019061157a91610fda565b61012085019061158991610fe8565b61014084019061159891611002565b6101608301906115a791611002565b6101808201906115b691610fb0565b60086115c190611010565b906115cb916112e9565b60096115d69061131e565b5f5f5f5f5f915f936115e6611321565b956115f090610fbe565b5f8701906115fd91610fb0565b61160690610fbe565b602086019061161491610fb0565b61161d90610fbe565b604085019061162b91610fb0565b61163490610fbe565b606084019061164291610fb0565b61164b90610fbe565b608083019061165991610fb0565b61166290610fbe565b60a082019061167091610fb0565b61167991611410565b565b9061168d999897969594939291610db4565b565b906116a19161169c6124b8565b61172d565b6116a961253a565b565b5f7f5061757361626c653a2070617573656400000000000000000000000000000000910152565b6116df6010602092610dd0565b6116e8816116ab565b0190565b6117019060208101905f8183039101526116d2565b90565b1561170b57565b611713610112565b62461bcd60e51b815280611729600482016116ec565b0390fd5b9061175c9161175761173f6001610600565b61175161174b5f61067c565b9161067c565b14611704565b6117e0565b565b5f7f74696d654265666f72653a2074696d65206973206f7665720000000000000000910152565b6117926018602092610dd0565b61179b8161175e565b0190565b6117b49060208101905f818303910152611785565b90565b156117be57565b6117c6610112565b62461bcd60e51b8152806117dc6004820161179f565b0390fd5b9061181c916118178161181161180b6118065f6117ff429560086101eb565b500161022f565b61012f565b9161012f565b106117b7565b6118a0565b565b5f7f73746174654d617463683a207374617465206973206e6f74206d617463680000910152565b611852601e602092610dd0565b61185b8161181e565b0190565b6118749060208101905f818303910152611845565b90565b1561187e57565b611886610112565b62461bcd60e51b81528061189c6004820161185f565b0390fd5b906118db916118d66118be60086118b784826101eb565b5001610288565b6118d06118ca5f6103d2565b916103d2565b14611877565b611bf2565b565b90565b90565b5f7f6465706f7369744c656e643a617070726f7665206661696c6564000000000000910152565b611917601a602092610dd0565b611920816118e3565b0190565b6119399060208101905f81830391015261190a565b90565b1561194357565b61194b610112565b62461bcd60e51b81528061196160048201611924565b0390fd5b634e487b7160e01b5f52601160045260245ffd5b61198861198e9193929361012f565b9261012f565b820180921161199957565b611965565b5f7f6465706f7369744c656e643a657863656564206d617820737570706c79000000910152565b6119d2601d602092610dd0565b6119db8161199e565b0190565b6119f49060208101905f8183039101526119c5565b90565b156119fe57565b611a06610112565b62461bcd60e51b815280611a1c600482016119df565b0390fd5b60207f616c20616d6f756e740000000000000000000000000000000000000000000000917f6465706f7369744c656e643a6d73672e76616c7565206973206e6f74206571755f8201520152565b611a7a6029604092610dd0565b611a8381611a20565b0190565b611a9c9060208101905f818303910152611a6d565b90565b15611aa657565b611aae610112565b62461bcd60e51b815280611ac460048201611a87565b0390fd5b60207f6d696e20616d6f756e7400000000000000000000000000000000000000000000917f6465706f7369744c656e643a616d6f756e74206973206d6f7265207468616e205f8201520152565b611b22602a604092610dd0565b611b2b81611ac8565b0190565b611b449060208101905f818303910152611b15565b90565b15611b4e57565b611b56610112565b62461bcd60e51b815280611b6c60048201611b2f565b0390fd5b60081b90565b90611b8361ff0091611b70565b9181191691161790565b611b969061067c565b90565b90565b90611bb1611bac611bb892611b8d565b611b99565b8254611b76565b9055565b90611bc860ff91611068565b9181191691161790565b90611be7611be2611bee92611b8d565b611b99565b8254611bbc565b9055565b611c24611c1f611c0d611c07600885906101eb565b506118dd565b92611c1a600b3390610bf2565b610c08565b6118e0565b91611c43611c3e611c376007850161025b565b83906125a4565b61193c565b611c80611c5c611c556004850161022f565b8390611979565b611c79611c73611c6e6003870161022f565b61012f565b9161012f565b11156119f7565b611c9c34611c96611c908461012f565b9161012f565b14611a9f565b611cc181611cbb611cb5611cb0600261022f565b61012f565b9161012f565b11611b47565b611cce5f60028501611b9c565b611cdb5f60028501611bd2565b611ce76007830161025b565b611d01611cfb611cf65f610ea0565b610396565b91610396565b145f14611d4d575090611d2e611d4a92611d28600434920191611d238361022f565b611979565b90611086565b611d445f34920191611d3f8361022f565b611979565b90611086565b5b565b600481611d76611d8d95611d705f611d8796920191611d6b8361022f565b611979565b90611086565b920191611d828361022f565b611979565b90611086565b611d4b565b90611d9c9161168f565b565b611daf90611daa6124b8565b611db9565b611db761253a565b565b611de790611de2611dca6001610600565b611ddc611dd65f61067c565b9161067c565b14611704565b611e6b565b565b5f7f74696d6541667465723a20747820697320746f6f206561726c79000000000000910152565b611e1d601a602092610dd0565b611e2681611de9565b0190565b611e3f9060208101905f818303910152611e10565b90565b15611e4957565b611e51610112565b62461bcd60e51b815280611e6760048201611e2a565b0390fd5b611ea690611ea181611e9b611e95611e905f611e89429560086101eb565b500161022f565b61012f565b9161012f565b11611e42565b611f2a565b565b5f7f73746174653a206e6f74206d6174636820616e6420756e646f6e650000000000910152565b611edc601b602092610dd0565b611ee581611ea8565b0190565b611efe9060208101905f818303910152611ecf565b90565b15611f0857565b611f10610112565b62461bcd60e51b815280611f2660048201611ee9565b0390fd5b611f7790611f7281611f496008611f428184906101eb565b5001610288565b611f5c611f5660016103d2565b916103d2565b148015611fab575b908115611f79575b50611f01565b61212e565b565b611f919150611f8a600891826101eb565b5001610288565b611fa4611f9e60036103d2565b916103d2565b145f611f6c565b50611fc36008611fbc8184906101eb565b5001610288565b611fd6611fd060026103d2565b916103d2565b14611f64565b90565b5f7f726566756e644c656e643a7374616b6520616d6f756e74206973207a65726f00910152565b612013601f602092610dd0565b61201c81611fdf565b0190565b6120359060208101905f818303910152612006565b90565b1561203f57565b612047610112565b62461bcd60e51b81528061205d60048201612020565b0390fd5b6120706120769193929361012f565b9261012f565b820391821161208157565b611965565b60207f65726f0000000000000000000000000000000000000000000000000000000000917f726566756e644c656e643a706f6f6c206c656e6420737570706c79206973207a5f8201520152565b6120e06023604092610dd0565b6120e981612086565b0190565b6121029060208101905f8183039101526120d3565b90565b1561210c57565b612114610112565b62461bcd60e51b81528061212a600482016120ed565b0390fd5b6121bd6121d5916121b75f6121b0600461215361214d600887906101eb565b506118dd565b6121aa6121928561218c61218761217561216f60098d90610a7f565b50611fdc565b9a612182600b3390610bf2565b610c08565b6118e0565b0161022f565b6121a461219e87610fbe565b9161012f565b11612038565b0161022f565b920161022f565b90612061565b6121cf6121c95f610fbe565b9161012f565b11612105565b565b6121e090611d9e565b565b6121eb90610416565b90565b60601b90565b6121fd906121ee565b90565b612209906121f4565b90565b61221861221d91610396565b612200565b9052565b60148161223361223b9383969561220c565b01809261220c565b0190565b60200190565b5190565b61225561225a91610213565b6105b4565b90565b6122867f8dddb57468cf5338ee155397ad1400a7a564308824f517d20a8a7c516523bb47612249565b90565b612292906103fa565b90565b61229e90612289565b90565b6122aa90610416565b90565b60e01b90565b6122bc8161067c565b036122c357565b5f80fd5b905051906122d4826122b3565b565b906020828203126122ef576122ec915f016122c7565b90565b61011c565b90565b612300906122f4565b9052565b9190612317905f602085019401906122f7565b565b612321610112565b3d5f823e3d90fd5b5f7f7369676e6174757265206661696c656400000000000000000000000000000000910152565b61235d6010602092610dd0565b61236681612329565b0190565b61237f9060208101905f818303910152612350565b90565b1561238957565b612391610112565b62461bcd60e51b8152806123a76004820161236a565b0390fd5b61243c6020336123e26123bd306121e2565b916123d46123c9610112565b938492868401612221565b848201810382520382610f64565b6123f46123ee82612245565b9161223f565b2061241561241061240b61240661225d565b612661565b612295565b6122a1565b612431633c403e38612425610112565b958694859384936122ad565b835260048301612304565b03915afa801561248757612457915f91612459575b50612382565b565b61247a915060203d8111612480575b6124728183610f64565b8101906122d6565b5f612451565b503d612468565b612319565b90565b6124a361249e6124a89261248c565b6103f7565b61012f565b90565b6124b5600261248f565b90565b6124c15f61022f565b6124da6124d46124cf6124ab565b61012f565b9161012f565b146124f2576124f06124ea6124ab565b5f611086565b565b5f633ee5aeb560e01b81528061250a6004820161084a565b0390fd5b90565b61252561252061252a9261250e565b6103f7565b61012f565b90565b6125376001612511565b90565b61254b61254561252d565b5f611086565b565b5f90565b61255a906103fa565b90565b61256690612551565b90565b61257290610416565b90565b61257e90610416565b90565b9160206125a292949361259b60408201965f8301906103a2565b0190610132565b565b6125c06125bb6020926125b561254d565b5061255d565b612569565b9163095ea7b3926125ed5f6125d430612575565b93956125f86125e1610112565b978896879586946122ad565b845260048401612581565b03925af190811561263c575f9161260e575b5090565b61262f915060203d8111612635575b6126278183610f64565b8101906122d6565b5f61260a565b503d61261d565b612319565b5f90565b61265961265461265e9261012f565b6103f7565b61038b565b90565b61268061268591612670612641565b50612679610d9a565b5054612645565b610416565b9056fea2646970667358221220113bc5fa40f8ac69918e2c35b7ab128e06ec805bc17ce602931ddf7d4a046fe564736f6c634300081c0033",
}

// AstralendABI is the input ABI used to generate the binding from.
// Deprecated: Use AstralendMetaData.ABI instead.
var AstralendABI = AstralendMetaData.ABI

// AstralendBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AstralendMetaData.Bin instead.
var AstralendBin = AstralendMetaData.Bin

// DeployAstralend deploys a new Ethereum contract, binding an instance of Astralend to it.
func DeployAstralend(auth *bind.TransactOpts, backend bind.ContractBackend, _oracle common.Address, _swapRouter common.Address, _feeAddress common.Address, _multiSignature common.Address) (common.Address, *types.Transaction, *Astralend, error) {
	parsed, err := AstralendMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AstralendBin), backend, _oracle, _swapRouter, _feeAddress, _multiSignature)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Astralend{AstralendCaller: AstralendCaller{contract: contract}, AstralendTransactor: AstralendTransactor{contract: contract}, AstralendFilterer: AstralendFilterer{contract: contract}}, nil
}

// Astralend is an auto generated Go binding around an Ethereum contract.
type Astralend struct {
	AstralendCaller     // Read-only binding to the contract
	AstralendTransactor // Write-only binding to the contract
	AstralendFilterer   // Log filterer for contract events
}

// AstralendCaller is an auto generated read-only Go binding around an Ethereum contract.
type AstralendCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AstralendTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AstralendTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AstralendFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AstralendFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AstralendSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AstralendSession struct {
	Contract     *Astralend        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AstralendCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AstralendCallerSession struct {
	Contract *AstralendCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// AstralendTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AstralendTransactorSession struct {
	Contract     *AstralendTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// AstralendRaw is an auto generated low-level Go binding around an Ethereum contract.
type AstralendRaw struct {
	Contract *Astralend // Generic contract binding to access the raw methods on
}

// AstralendCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AstralendCallerRaw struct {
	Contract *AstralendCaller // Generic read-only contract binding to access the raw methods on
}

// AstralendTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AstralendTransactorRaw struct {
	Contract *AstralendTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAstralend creates a new instance of Astralend, bound to a specific deployed contract.
func NewAstralend(address common.Address, backend bind.ContractBackend) (*Astralend, error) {
	contract, err := bindAstralend(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Astralend{AstralendCaller: AstralendCaller{contract: contract}, AstralendTransactor: AstralendTransactor{contract: contract}, AstralendFilterer: AstralendFilterer{contract: contract}}, nil
}

// NewAstralendCaller creates a new read-only instance of Astralend, bound to a specific deployed contract.
func NewAstralendCaller(address common.Address, caller bind.ContractCaller) (*AstralendCaller, error) {
	contract, err := bindAstralend(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AstralendCaller{contract: contract}, nil
}

// NewAstralendTransactor creates a new write-only instance of Astralend, bound to a specific deployed contract.
func NewAstralendTransactor(address common.Address, transactor bind.ContractTransactor) (*AstralendTransactor, error) {
	contract, err := bindAstralend(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AstralendTransactor{contract: contract}, nil
}

// NewAstralendFilterer creates a new log filterer instance of Astralend, bound to a specific deployed contract.
func NewAstralendFilterer(address common.Address, filterer bind.ContractFilterer) (*AstralendFilterer, error) {
	contract, err := bindAstralend(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AstralendFilterer{contract: contract}, nil
}

// bindAstralend binds a generic wrapper to an already deployed contract.
func bindAstralend(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AstralendMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Astralend *AstralendRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Astralend.Contract.AstralendCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Astralend *AstralendRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Astralend.Contract.AstralendTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Astralend *AstralendRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Astralend.Contract.AstralendTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Astralend *AstralendCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Astralend.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Astralend *AstralendTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Astralend.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Astralend *AstralendTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Astralend.Contract.contract.Transact(opts, method, params...)
}

// BorrowFee is a free data retrieval call binding the contract method 0xe626648a.
//
// Solidity: function borrowFee() view returns(uint256)
func (_Astralend *AstralendCaller) BorrowFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "borrowFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BorrowFee is a free data retrieval call binding the contract method 0xe626648a.
//
// Solidity: function borrowFee() view returns(uint256)
func (_Astralend *AstralendSession) BorrowFee() (*big.Int, error) {
	return _Astralend.Contract.BorrowFee(&_Astralend.CallOpts)
}

// BorrowFee is a free data retrieval call binding the contract method 0xe626648a.
//
// Solidity: function borrowFee() view returns(uint256)
func (_Astralend *AstralendCallerSession) BorrowFee() (*big.Int, error) {
	return _Astralend.Contract.BorrowFee(&_Astralend.CallOpts)
}

// FeeAddress is a free data retrieval call binding the contract method 0x41275358.
//
// Solidity: function feeAddress() view returns(address)
func (_Astralend *AstralendCaller) FeeAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "feeAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeAddress is a free data retrieval call binding the contract method 0x41275358.
//
// Solidity: function feeAddress() view returns(address)
func (_Astralend *AstralendSession) FeeAddress() (common.Address, error) {
	return _Astralend.Contract.FeeAddress(&_Astralend.CallOpts)
}

// FeeAddress is a free data retrieval call binding the contract method 0x41275358.
//
// Solidity: function feeAddress() view returns(address)
func (_Astralend *AstralendCallerSession) FeeAddress() (common.Address, error) {
	return _Astralend.Contract.FeeAddress(&_Astralend.CallOpts)
}

// GlobalPaused is a free data retrieval call binding the contract method 0x61a552dc.
//
// Solidity: function globalPaused() view returns(bool)
func (_Astralend *AstralendCaller) GlobalPaused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "globalPaused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// GlobalPaused is a free data retrieval call binding the contract method 0x61a552dc.
//
// Solidity: function globalPaused() view returns(bool)
func (_Astralend *AstralendSession) GlobalPaused() (bool, error) {
	return _Astralend.Contract.GlobalPaused(&_Astralend.CallOpts)
}

// GlobalPaused is a free data retrieval call binding the contract method 0x61a552dc.
//
// Solidity: function globalPaused() view returns(bool)
func (_Astralend *AstralendCallerSession) GlobalPaused() (bool, error) {
	return _Astralend.Contract.GlobalPaused(&_Astralend.CallOpts)
}

// LendFee is a free data retrieval call binding the contract method 0x4aea0aec.
//
// Solidity: function lendFee() view returns(uint256)
func (_Astralend *AstralendCaller) LendFee(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "lendFee")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LendFee is a free data retrieval call binding the contract method 0x4aea0aec.
//
// Solidity: function lendFee() view returns(uint256)
func (_Astralend *AstralendSession) LendFee() (*big.Int, error) {
	return _Astralend.Contract.LendFee(&_Astralend.CallOpts)
}

// LendFee is a free data retrieval call binding the contract method 0x4aea0aec.
//
// Solidity: function lendFee() view returns(uint256)
func (_Astralend *AstralendCallerSession) LendFee() (*big.Int, error) {
	return _Astralend.Contract.LendFee(&_Astralend.CallOpts)
}

// MinAmount is a free data retrieval call binding the contract method 0x9b2cb5d8.
//
// Solidity: function minAmount() view returns(uint256)
func (_Astralend *AstralendCaller) MinAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "minAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinAmount is a free data retrieval call binding the contract method 0x9b2cb5d8.
//
// Solidity: function minAmount() view returns(uint256)
func (_Astralend *AstralendSession) MinAmount() (*big.Int, error) {
	return _Astralend.Contract.MinAmount(&_Astralend.CallOpts)
}

// MinAmount is a free data retrieval call binding the contract method 0x9b2cb5d8.
//
// Solidity: function minAmount() view returns(uint256)
func (_Astralend *AstralendCallerSession) MinAmount() (*big.Int, error) {
	return _Astralend.Contract.MinAmount(&_Astralend.CallOpts)
}

// Oracle is a free data retrieval call binding the contract method 0x7dc0d1d0.
//
// Solidity: function oracle() view returns(address)
func (_Astralend *AstralendCaller) Oracle(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "oracle")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Oracle is a free data retrieval call binding the contract method 0x7dc0d1d0.
//
// Solidity: function oracle() view returns(address)
func (_Astralend *AstralendSession) Oracle() (common.Address, error) {
	return _Astralend.Contract.Oracle(&_Astralend.CallOpts)
}

// Oracle is a free data retrieval call binding the contract method 0x7dc0d1d0.
//
// Solidity: function oracle() view returns(address)
func (_Astralend *AstralendCallerSession) Oracle() (common.Address, error) {
	return _Astralend.Contract.Oracle(&_Astralend.CallOpts)
}

// PoolBaseInfos is a free data retrieval call binding the contract method 0x0d6abfc1.
//
// Solidity: function poolBaseInfos(uint256 ) view returns(uint256 settleTime, uint256 endTime, uint256 interestRate, uint256 maxSupply, uint256 lendSupply, uint256 borrowSupply, uint256 mortgageRate, address lendToken, address borrowToken, uint8 state, address spCoin, address jpCoin, uint256 autoLiquidateThreshold)
func (_Astralend *AstralendCaller) PoolBaseInfos(opts *bind.CallOpts, arg0 *big.Int) (struct {
	SettleTime             *big.Int
	EndTime                *big.Int
	InterestRate           *big.Int
	MaxSupply              *big.Int
	LendSupply             *big.Int
	BorrowSupply           *big.Int
	MortgageRate           *big.Int
	LendToken              common.Address
	BorrowToken            common.Address
	State                  uint8
	SpCoin                 common.Address
	JpCoin                 common.Address
	AutoLiquidateThreshold *big.Int
}, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "poolBaseInfos", arg0)

	outstruct := new(struct {
		SettleTime             *big.Int
		EndTime                *big.Int
		InterestRate           *big.Int
		MaxSupply              *big.Int
		LendSupply             *big.Int
		BorrowSupply           *big.Int
		MortgageRate           *big.Int
		LendToken              common.Address
		BorrowToken            common.Address
		State                  uint8
		SpCoin                 common.Address
		JpCoin                 common.Address
		AutoLiquidateThreshold *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.SettleTime = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.EndTime = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.InterestRate = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.MaxSupply = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.LendSupply = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.BorrowSupply = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.MortgageRate = *abi.ConvertType(out[6], new(*big.Int)).(**big.Int)
	outstruct.LendToken = *abi.ConvertType(out[7], new(common.Address)).(*common.Address)
	outstruct.BorrowToken = *abi.ConvertType(out[8], new(common.Address)).(*common.Address)
	outstruct.State = *abi.ConvertType(out[9], new(uint8)).(*uint8)
	outstruct.SpCoin = *abi.ConvertType(out[10], new(common.Address)).(*common.Address)
	outstruct.JpCoin = *abi.ConvertType(out[11], new(common.Address)).(*common.Address)
	outstruct.AutoLiquidateThreshold = *abi.ConvertType(out[12], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// PoolBaseInfos is a free data retrieval call binding the contract method 0x0d6abfc1.
//
// Solidity: function poolBaseInfos(uint256 ) view returns(uint256 settleTime, uint256 endTime, uint256 interestRate, uint256 maxSupply, uint256 lendSupply, uint256 borrowSupply, uint256 mortgageRate, address lendToken, address borrowToken, uint8 state, address spCoin, address jpCoin, uint256 autoLiquidateThreshold)
func (_Astralend *AstralendSession) PoolBaseInfos(arg0 *big.Int) (struct {
	SettleTime             *big.Int
	EndTime                *big.Int
	InterestRate           *big.Int
	MaxSupply              *big.Int
	LendSupply             *big.Int
	BorrowSupply           *big.Int
	MortgageRate           *big.Int
	LendToken              common.Address
	BorrowToken            common.Address
	State                  uint8
	SpCoin                 common.Address
	JpCoin                 common.Address
	AutoLiquidateThreshold *big.Int
}, error) {
	return _Astralend.Contract.PoolBaseInfos(&_Astralend.CallOpts, arg0)
}

// PoolBaseInfos is a free data retrieval call binding the contract method 0x0d6abfc1.
//
// Solidity: function poolBaseInfos(uint256 ) view returns(uint256 settleTime, uint256 endTime, uint256 interestRate, uint256 maxSupply, uint256 lendSupply, uint256 borrowSupply, uint256 mortgageRate, address lendToken, address borrowToken, uint8 state, address spCoin, address jpCoin, uint256 autoLiquidateThreshold)
func (_Astralend *AstralendCallerSession) PoolBaseInfos(arg0 *big.Int) (struct {
	SettleTime             *big.Int
	EndTime                *big.Int
	InterestRate           *big.Int
	MaxSupply              *big.Int
	LendSupply             *big.Int
	BorrowSupply           *big.Int
	MortgageRate           *big.Int
	LendToken              common.Address
	BorrowToken            common.Address
	State                  uint8
	SpCoin                 common.Address
	JpCoin                 common.Address
	AutoLiquidateThreshold *big.Int
}, error) {
	return _Astralend.Contract.PoolBaseInfos(&_Astralend.CallOpts, arg0)
}

// PoolDataInfos is a free data retrieval call binding the contract method 0x981b48a6.
//
// Solidity: function poolDataInfos(uint256 ) view returns(uint256 settleAmountLend, uint256 settleAmountBorrow, uint256 finishAmountLend, uint256 finishAmountBorrow, uint256 liquidationAmounLend, uint256 liquidationAmounBorrow)
func (_Astralend *AstralendCaller) PoolDataInfos(opts *bind.CallOpts, arg0 *big.Int) (struct {
	SettleAmountLend       *big.Int
	SettleAmountBorrow     *big.Int
	FinishAmountLend       *big.Int
	FinishAmountBorrow     *big.Int
	LiquidationAmounLend   *big.Int
	LiquidationAmounBorrow *big.Int
}, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "poolDataInfos", arg0)

	outstruct := new(struct {
		SettleAmountLend       *big.Int
		SettleAmountBorrow     *big.Int
		FinishAmountLend       *big.Int
		FinishAmountBorrow     *big.Int
		LiquidationAmounLend   *big.Int
		LiquidationAmounBorrow *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.SettleAmountLend = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.SettleAmountBorrow = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.FinishAmountLend = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.FinishAmountBorrow = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.LiquidationAmounLend = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.LiquidationAmounBorrow = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// PoolDataInfos is a free data retrieval call binding the contract method 0x981b48a6.
//
// Solidity: function poolDataInfos(uint256 ) view returns(uint256 settleAmountLend, uint256 settleAmountBorrow, uint256 finishAmountLend, uint256 finishAmountBorrow, uint256 liquidationAmounLend, uint256 liquidationAmounBorrow)
func (_Astralend *AstralendSession) PoolDataInfos(arg0 *big.Int) (struct {
	SettleAmountLend       *big.Int
	SettleAmountBorrow     *big.Int
	FinishAmountLend       *big.Int
	FinishAmountBorrow     *big.Int
	LiquidationAmounLend   *big.Int
	LiquidationAmounBorrow *big.Int
}, error) {
	return _Astralend.Contract.PoolDataInfos(&_Astralend.CallOpts, arg0)
}

// PoolDataInfos is a free data retrieval call binding the contract method 0x981b48a6.
//
// Solidity: function poolDataInfos(uint256 ) view returns(uint256 settleAmountLend, uint256 settleAmountBorrow, uint256 finishAmountLend, uint256 finishAmountBorrow, uint256 liquidationAmounLend, uint256 liquidationAmounBorrow)
func (_Astralend *AstralendCallerSession) PoolDataInfos(arg0 *big.Int) (struct {
	SettleAmountLend       *big.Int
	SettleAmountBorrow     *big.Int
	FinishAmountLend       *big.Int
	FinishAmountBorrow     *big.Int
	LiquidationAmounLend   *big.Int
	LiquidationAmounBorrow *big.Int
}, error) {
	return _Astralend.Contract.PoolDataInfos(&_Astralend.CallOpts, arg0)
}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_Astralend *AstralendCaller) PoolLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "poolLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_Astralend *AstralendSession) PoolLength() (*big.Int, error) {
	return _Astralend.Contract.PoolLength(&_Astralend.CallOpts)
}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_Astralend *AstralendCallerSession) PoolLength() (*big.Int, error) {
	return _Astralend.Contract.PoolLength(&_Astralend.CallOpts)
}

// SwapRouter is a free data retrieval call binding the contract method 0xc31c9c07.
//
// Solidity: function swapRouter() view returns(address)
func (_Astralend *AstralendCaller) SwapRouter(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "swapRouter")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SwapRouter is a free data retrieval call binding the contract method 0xc31c9c07.
//
// Solidity: function swapRouter() view returns(address)
func (_Astralend *AstralendSession) SwapRouter() (common.Address, error) {
	return _Astralend.Contract.SwapRouter(&_Astralend.CallOpts)
}

// SwapRouter is a free data retrieval call binding the contract method 0xc31c9c07.
//
// Solidity: function swapRouter() view returns(address)
func (_Astralend *AstralendCallerSession) SwapRouter() (common.Address, error) {
	return _Astralend.Contract.SwapRouter(&_Astralend.CallOpts)
}

// UserBorrowInfo is a free data retrieval call binding the contract method 0x3c9fadc3.
//
// Solidity: function userBorrowInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendCaller) UserBorrowInfo(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "userBorrowInfo", arg0, arg1)

	outstruct := new(struct {
		StakeAmount  *big.Int
		RefundAmount *big.Int
		HasNoRefund  bool
		HasNoClaim   bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.StakeAmount = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.RefundAmount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.HasNoRefund = *abi.ConvertType(out[2], new(bool)).(*bool)
	outstruct.HasNoClaim = *abi.ConvertType(out[3], new(bool)).(*bool)

	return *outstruct, err

}

// UserBorrowInfo is a free data retrieval call binding the contract method 0x3c9fadc3.
//
// Solidity: function userBorrowInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendSession) UserBorrowInfo(arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	return _Astralend.Contract.UserBorrowInfo(&_Astralend.CallOpts, arg0, arg1)
}

// UserBorrowInfo is a free data retrieval call binding the contract method 0x3c9fadc3.
//
// Solidity: function userBorrowInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendCallerSession) UserBorrowInfo(arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	return _Astralend.Contract.UserBorrowInfo(&_Astralend.CallOpts, arg0, arg1)
}

// UserLendInfo is a free data retrieval call binding the contract method 0xbb176a64.
//
// Solidity: function userLendInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendCaller) UserLendInfo(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	var out []interface{}
	err := _Astralend.contract.Call(opts, &out, "userLendInfo", arg0, arg1)

	outstruct := new(struct {
		StakeAmount  *big.Int
		RefundAmount *big.Int
		HasNoRefund  bool
		HasNoClaim   bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.StakeAmount = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.RefundAmount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.HasNoRefund = *abi.ConvertType(out[2], new(bool)).(*bool)
	outstruct.HasNoClaim = *abi.ConvertType(out[3], new(bool)).(*bool)

	return *outstruct, err

}

// UserLendInfo is a free data retrieval call binding the contract method 0xbb176a64.
//
// Solidity: function userLendInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendSession) UserLendInfo(arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	return _Astralend.Contract.UserLendInfo(&_Astralend.CallOpts, arg0, arg1)
}

// UserLendInfo is a free data retrieval call binding the contract method 0xbb176a64.
//
// Solidity: function userLendInfo(address , uint256 ) view returns(uint256 stakeAmount, uint256 refundAmount, bool hasNoRefund, bool hasNoClaim)
func (_Astralend *AstralendCallerSession) UserLendInfo(arg0 common.Address, arg1 *big.Int) (struct {
	StakeAmount  *big.Int
	RefundAmount *big.Int
	HasNoRefund  bool
	HasNoClaim   bool
}, error) {
	return _Astralend.Contract.UserLendInfo(&_Astralend.CallOpts, arg0, arg1)
}

// CreatePool is a paid mutator transaction binding the contract method 0x459b911c.
//
// Solidity: function createPool(uint256 _settleTime, uint256 _endTime, uint256 _interestRate, uint256 _maxSupply, uint256 _mortgageRate, address _lendToken, address _borrowToken, address _spCoin, address _jpCoin, uint256 _autoLiquidateThreshold) returns()
func (_Astralend *AstralendTransactor) CreatePool(opts *bind.TransactOpts, _settleTime *big.Int, _endTime *big.Int, _interestRate *big.Int, _maxSupply *big.Int, _mortgageRate *big.Int, _lendToken common.Address, _borrowToken common.Address, _spCoin common.Address, _jpCoin common.Address, _autoLiquidateThreshold *big.Int) (*types.Transaction, error) {
	return _Astralend.contract.Transact(opts, "createPool", _settleTime, _endTime, _interestRate, _maxSupply, _mortgageRate, _lendToken, _borrowToken, _spCoin, _jpCoin, _autoLiquidateThreshold)
}

// CreatePool is a paid mutator transaction binding the contract method 0x459b911c.
//
// Solidity: function createPool(uint256 _settleTime, uint256 _endTime, uint256 _interestRate, uint256 _maxSupply, uint256 _mortgageRate, address _lendToken, address _borrowToken, address _spCoin, address _jpCoin, uint256 _autoLiquidateThreshold) returns()
func (_Astralend *AstralendSession) CreatePool(_settleTime *big.Int, _endTime *big.Int, _interestRate *big.Int, _maxSupply *big.Int, _mortgageRate *big.Int, _lendToken common.Address, _borrowToken common.Address, _spCoin common.Address, _jpCoin common.Address, _autoLiquidateThreshold *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.CreatePool(&_Astralend.TransactOpts, _settleTime, _endTime, _interestRate, _maxSupply, _mortgageRate, _lendToken, _borrowToken, _spCoin, _jpCoin, _autoLiquidateThreshold)
}

// CreatePool is a paid mutator transaction binding the contract method 0x459b911c.
//
// Solidity: function createPool(uint256 _settleTime, uint256 _endTime, uint256 _interestRate, uint256 _maxSupply, uint256 _mortgageRate, address _lendToken, address _borrowToken, address _spCoin, address _jpCoin, uint256 _autoLiquidateThreshold) returns()
func (_Astralend *AstralendTransactorSession) CreatePool(_settleTime *big.Int, _endTime *big.Int, _interestRate *big.Int, _maxSupply *big.Int, _mortgageRate *big.Int, _lendToken common.Address, _borrowToken common.Address, _spCoin common.Address, _jpCoin common.Address, _autoLiquidateThreshold *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.CreatePool(&_Astralend.TransactOpts, _settleTime, _endTime, _interestRate, _maxSupply, _mortgageRate, _lendToken, _borrowToken, _spCoin, _jpCoin, _autoLiquidateThreshold)
}

// DepositLend is a paid mutator transaction binding the contract method 0x90590da0.
//
// Solidity: function depositLend(uint256 _poolIndex, uint256 _amount) payable returns()
func (_Astralend *AstralendTransactor) DepositLend(opts *bind.TransactOpts, _poolIndex *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _Astralend.contract.Transact(opts, "depositLend", _poolIndex, _amount)
}

// DepositLend is a paid mutator transaction binding the contract method 0x90590da0.
//
// Solidity: function depositLend(uint256 _poolIndex, uint256 _amount) payable returns()
func (_Astralend *AstralendSession) DepositLend(_poolIndex *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.DepositLend(&_Astralend.TransactOpts, _poolIndex, _amount)
}

// DepositLend is a paid mutator transaction binding the contract method 0x90590da0.
//
// Solidity: function depositLend(uint256 _poolIndex, uint256 _amount) payable returns()
func (_Astralend *AstralendTransactorSession) DepositLend(_poolIndex *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.DepositLend(&_Astralend.TransactOpts, _poolIndex, _amount)
}

// RefundLend is a paid mutator transaction binding the contract method 0xeec8d506.
//
// Solidity: function refundLend(uint256 _poolIndex) returns()
func (_Astralend *AstralendTransactor) RefundLend(opts *bind.TransactOpts, _poolIndex *big.Int) (*types.Transaction, error) {
	return _Astralend.contract.Transact(opts, "refundLend", _poolIndex)
}

// RefundLend is a paid mutator transaction binding the contract method 0xeec8d506.
//
// Solidity: function refundLend(uint256 _poolIndex) returns()
func (_Astralend *AstralendSession) RefundLend(_poolIndex *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.RefundLend(&_Astralend.TransactOpts, _poolIndex)
}

// RefundLend is a paid mutator transaction binding the contract method 0xeec8d506.
//
// Solidity: function refundLend(uint256 _poolIndex) returns()
func (_Astralend *AstralendTransactorSession) RefundLend(_poolIndex *big.Int) (*types.Transaction, error) {
	return _Astralend.Contract.RefundLend(&_Astralend.TransactOpts, _poolIndex)
}

// AstralendClaimBorrowIterator is returned from FilterClaimBorrow and is used to iterate over the raw logs and unpacked data for ClaimBorrow events raised by the Astralend contract.
type AstralendClaimBorrowIterator struct {
	Event *AstralendClaimBorrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendClaimBorrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendClaimBorrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendClaimBorrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendClaimBorrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendClaimBorrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendClaimBorrow represents a ClaimBorrow event raised by the Astralend contract.
type AstralendClaimBorrow struct {
	From   common.Address
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterClaimBorrow is a free log retrieval operation binding the contract event 0x3ddafe3ebb4d0c818317027aabfa82dc9983942ceeb80523167e2de047b17fbd.
//
// Solidity: event ClaimBorrow(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) FilterClaimBorrow(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendClaimBorrowIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "ClaimBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendClaimBorrowIterator{contract: _Astralend.contract, event: "ClaimBorrow", logs: logs, sub: sub}, nil
}

// WatchClaimBorrow is a free log subscription operation binding the contract event 0x3ddafe3ebb4d0c818317027aabfa82dc9983942ceeb80523167e2de047b17fbd.
//
// Solidity: event ClaimBorrow(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) WatchClaimBorrow(opts *bind.WatchOpts, sink chan<- *AstralendClaimBorrow, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "ClaimBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendClaimBorrow)
				if err := _Astralend.contract.UnpackLog(event, "ClaimBorrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaimBorrow is a log parse operation binding the contract event 0x3ddafe3ebb4d0c818317027aabfa82dc9983942ceeb80523167e2de047b17fbd.
//
// Solidity: event ClaimBorrow(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) ParseClaimBorrow(log types.Log) (*AstralendClaimBorrow, error) {
	event := new(AstralendClaimBorrow)
	if err := _Astralend.contract.UnpackLog(event, "ClaimBorrow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendClaimLendIterator is returned from FilterClaimLend and is used to iterate over the raw logs and unpacked data for ClaimLend events raised by the Astralend contract.
type AstralendClaimLendIterator struct {
	Event *AstralendClaimLend // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendClaimLendIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendClaimLend)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendClaimLend)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendClaimLendIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendClaimLendIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendClaimLend represents a ClaimLend event raised by the Astralend contract.
type AstralendClaimLend struct {
	From   common.Address
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterClaimLend is a free log retrieval operation binding the contract event 0x6f4dd2687b3c3bfa99d39742b01d6e0ad9604c48559791d5df4ff5df44b41dfd.
//
// Solidity: event ClaimLend(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) FilterClaimLend(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendClaimLendIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "ClaimLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendClaimLendIterator{contract: _Astralend.contract, event: "ClaimLend", logs: logs, sub: sub}, nil
}

// WatchClaimLend is a free log subscription operation binding the contract event 0x6f4dd2687b3c3bfa99d39742b01d6e0ad9604c48559791d5df4ff5df44b41dfd.
//
// Solidity: event ClaimLend(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) WatchClaimLend(opts *bind.WatchOpts, sink chan<- *AstralendClaimLend, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "ClaimLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendClaimLend)
				if err := _Astralend.contract.UnpackLog(event, "ClaimLend", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaimLend is a log parse operation binding the contract event 0x6f4dd2687b3c3bfa99d39742b01d6e0ad9604c48559791d5df4ff5df44b41dfd.
//
// Solidity: event ClaimLend(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) ParseClaimLend(log types.Log) (*AstralendClaimLend, error) {
	event := new(AstralendClaimLend)
	if err := _Astralend.contract.UnpackLog(event, "ClaimLend", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendDepositBorrowIterator is returned from FilterDepositBorrow and is used to iterate over the raw logs and unpacked data for DepositBorrow events raised by the Astralend contract.
type AstralendDepositBorrowIterator struct {
	Event *AstralendDepositBorrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendDepositBorrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendDepositBorrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendDepositBorrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendDepositBorrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendDepositBorrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendDepositBorrow represents a DepositBorrow event raised by the Astralend contract.
type AstralendDepositBorrow struct {
	From       common.Address
	Token      common.Address
	Amount     *big.Int
	MintAmount *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterDepositBorrow is a free log retrieval operation binding the contract event 0x1d7b72e666a0b6217efe7cfa1b604ea5c7b39219563ce48b30c9da77045247a5.
//
// Solidity: event DepositBorrow(address indexed from, address indexed token, uint256 amount, uint256 mintAmount)
func (_Astralend *AstralendFilterer) FilterDepositBorrow(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendDepositBorrowIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "DepositBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendDepositBorrowIterator{contract: _Astralend.contract, event: "DepositBorrow", logs: logs, sub: sub}, nil
}

// WatchDepositBorrow is a free log subscription operation binding the contract event 0x1d7b72e666a0b6217efe7cfa1b604ea5c7b39219563ce48b30c9da77045247a5.
//
// Solidity: event DepositBorrow(address indexed from, address indexed token, uint256 amount, uint256 mintAmount)
func (_Astralend *AstralendFilterer) WatchDepositBorrow(opts *bind.WatchOpts, sink chan<- *AstralendDepositBorrow, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "DepositBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendDepositBorrow)
				if err := _Astralend.contract.UnpackLog(event, "DepositBorrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDepositBorrow is a log parse operation binding the contract event 0x1d7b72e666a0b6217efe7cfa1b604ea5c7b39219563ce48b30c9da77045247a5.
//
// Solidity: event DepositBorrow(address indexed from, address indexed token, uint256 amount, uint256 mintAmount)
func (_Astralend *AstralendFilterer) ParseDepositBorrow(log types.Log) (*AstralendDepositBorrow, error) {
	event := new(AstralendDepositBorrow)
	if err := _Astralend.contract.UnpackLog(event, "DepositBorrow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendEmergencyBorrowWithdrawalIterator is returned from FilterEmergencyBorrowWithdrawal and is used to iterate over the raw logs and unpacked data for EmergencyBorrowWithdrawal events raised by the Astralend contract.
type AstralendEmergencyBorrowWithdrawalIterator struct {
	Event *AstralendEmergencyBorrowWithdrawal // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendEmergencyBorrowWithdrawalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendEmergencyBorrowWithdrawal)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendEmergencyBorrowWithdrawal)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendEmergencyBorrowWithdrawalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendEmergencyBorrowWithdrawalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendEmergencyBorrowWithdrawal represents a EmergencyBorrowWithdrawal event raised by the Astralend contract.
type AstralendEmergencyBorrowWithdrawal struct {
	From   common.Address
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEmergencyBorrowWithdrawal is a free log retrieval operation binding the contract event 0x5a06c7de92f1dc59e8cba872927d016c80ce5f0fb2295c898dfb7a2f08e43fb1.
//
// Solidity: event EmergencyBorrowWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) FilterEmergencyBorrowWithdrawal(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendEmergencyBorrowWithdrawalIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "EmergencyBorrowWithdrawal", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendEmergencyBorrowWithdrawalIterator{contract: _Astralend.contract, event: "EmergencyBorrowWithdrawal", logs: logs, sub: sub}, nil
}

// WatchEmergencyBorrowWithdrawal is a free log subscription operation binding the contract event 0x5a06c7de92f1dc59e8cba872927d016c80ce5f0fb2295c898dfb7a2f08e43fb1.
//
// Solidity: event EmergencyBorrowWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) WatchEmergencyBorrowWithdrawal(opts *bind.WatchOpts, sink chan<- *AstralendEmergencyBorrowWithdrawal, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "EmergencyBorrowWithdrawal", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendEmergencyBorrowWithdrawal)
				if err := _Astralend.contract.UnpackLog(event, "EmergencyBorrowWithdrawal", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEmergencyBorrowWithdrawal is a log parse operation binding the contract event 0x5a06c7de92f1dc59e8cba872927d016c80ce5f0fb2295c898dfb7a2f08e43fb1.
//
// Solidity: event EmergencyBorrowWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) ParseEmergencyBorrowWithdrawal(log types.Log) (*AstralendEmergencyBorrowWithdrawal, error) {
	event := new(AstralendEmergencyBorrowWithdrawal)
	if err := _Astralend.contract.UnpackLog(event, "EmergencyBorrowWithdrawal", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendEmergencyLendWithdrawalIterator is returned from FilterEmergencyLendWithdrawal and is used to iterate over the raw logs and unpacked data for EmergencyLendWithdrawal events raised by the Astralend contract.
type AstralendEmergencyLendWithdrawalIterator struct {
	Event *AstralendEmergencyLendWithdrawal // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendEmergencyLendWithdrawalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendEmergencyLendWithdrawal)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendEmergencyLendWithdrawal)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendEmergencyLendWithdrawalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendEmergencyLendWithdrawalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendEmergencyLendWithdrawal represents a EmergencyLendWithdrawal event raised by the Astralend contract.
type AstralendEmergencyLendWithdrawal struct {
	From   common.Address
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEmergencyLendWithdrawal is a free log retrieval operation binding the contract event 0x71d14c5f08cb34cbfb59c06ea5151aafbf742d0b6ed00fdb83addd9afb5c0fd0.
//
// Solidity: event EmergencyLendWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) FilterEmergencyLendWithdrawal(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendEmergencyLendWithdrawalIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "EmergencyLendWithdrawal", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendEmergencyLendWithdrawalIterator{contract: _Astralend.contract, event: "EmergencyLendWithdrawal", logs: logs, sub: sub}, nil
}

// WatchEmergencyLendWithdrawal is a free log subscription operation binding the contract event 0x71d14c5f08cb34cbfb59c06ea5151aafbf742d0b6ed00fdb83addd9afb5c0fd0.
//
// Solidity: event EmergencyLendWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) WatchEmergencyLendWithdrawal(opts *bind.WatchOpts, sink chan<- *AstralendEmergencyLendWithdrawal, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "EmergencyLendWithdrawal", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendEmergencyLendWithdrawal)
				if err := _Astralend.contract.UnpackLog(event, "EmergencyLendWithdrawal", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEmergencyLendWithdrawal is a log parse operation binding the contract event 0x71d14c5f08cb34cbfb59c06ea5151aafbf742d0b6ed00fdb83addd9afb5c0fd0.
//
// Solidity: event EmergencyLendWithdrawal(address indexed from, address indexed token, uint256 amount)
func (_Astralend *AstralendFilterer) ParseEmergencyLendWithdrawal(log types.Log) (*AstralendEmergencyLendWithdrawal, error) {
	event := new(AstralendEmergencyLendWithdrawal)
	if err := _Astralend.contract.UnpackLog(event, "EmergencyLendWithdrawal", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendRefundBorrowIterator is returned from FilterRefundBorrow and is used to iterate over the raw logs and unpacked data for RefundBorrow events raised by the Astralend contract.
type AstralendRefundBorrowIterator struct {
	Event *AstralendRefundBorrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendRefundBorrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendRefundBorrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendRefundBorrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendRefundBorrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendRefundBorrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendRefundBorrow represents a RefundBorrow event raised by the Astralend contract.
type AstralendRefundBorrow struct {
	From   common.Address
	Token  common.Address
	Refund *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRefundBorrow is a free log retrieval operation binding the contract event 0x732816f48de550f238bd0d4f5b79819c7b24a49d6132928978e3cd36568dd5db.
//
// Solidity: event RefundBorrow(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) FilterRefundBorrow(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendRefundBorrowIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "RefundBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendRefundBorrowIterator{contract: _Astralend.contract, event: "RefundBorrow", logs: logs, sub: sub}, nil
}

// WatchRefundBorrow is a free log subscription operation binding the contract event 0x732816f48de550f238bd0d4f5b79819c7b24a49d6132928978e3cd36568dd5db.
//
// Solidity: event RefundBorrow(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) WatchRefundBorrow(opts *bind.WatchOpts, sink chan<- *AstralendRefundBorrow, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "RefundBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendRefundBorrow)
				if err := _Astralend.contract.UnpackLog(event, "RefundBorrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRefundBorrow is a log parse operation binding the contract event 0x732816f48de550f238bd0d4f5b79819c7b24a49d6132928978e3cd36568dd5db.
//
// Solidity: event RefundBorrow(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) ParseRefundBorrow(log types.Log) (*AstralendRefundBorrow, error) {
	event := new(AstralendRefundBorrow)
	if err := _Astralend.contract.UnpackLog(event, "RefundBorrow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendRefundLendIterator is returned from FilterRefundLend and is used to iterate over the raw logs and unpacked data for RefundLend events raised by the Astralend contract.
type AstralendRefundLendIterator struct {
	Event *AstralendRefundLend // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendRefundLendIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendRefundLend)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendRefundLend)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendRefundLendIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendRefundLendIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendRefundLend represents a RefundLend event raised by the Astralend contract.
type AstralendRefundLend struct {
	From   common.Address
	Token  common.Address
	Refund *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRefundLend is a free log retrieval operation binding the contract event 0xc3e20279d41b3ed21d277920877e5e5c6665bf6aca607046a3fe0fd2bd6bda7d.
//
// Solidity: event RefundLend(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) FilterRefundLend(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendRefundLendIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "RefundLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendRefundLendIterator{contract: _Astralend.contract, event: "RefundLend", logs: logs, sub: sub}, nil
}

// WatchRefundLend is a free log subscription operation binding the contract event 0xc3e20279d41b3ed21d277920877e5e5c6665bf6aca607046a3fe0fd2bd6bda7d.
//
// Solidity: event RefundLend(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) WatchRefundLend(opts *bind.WatchOpts, sink chan<- *AstralendRefundLend, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "RefundLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendRefundLend)
				if err := _Astralend.contract.UnpackLog(event, "RefundLend", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRefundLend is a log parse operation binding the contract event 0xc3e20279d41b3ed21d277920877e5e5c6665bf6aca607046a3fe0fd2bd6bda7d.
//
// Solidity: event RefundLend(address indexed from, address indexed token, uint256 refund)
func (_Astralend *AstralendFilterer) ParseRefundLend(log types.Log) (*AstralendRefundLend, error) {
	event := new(AstralendRefundLend)
	if err := _Astralend.contract.UnpackLog(event, "RefundLend", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendSetFeeIterator is returned from FilterSetFee and is used to iterate over the raw logs and unpacked data for SetFee events raised by the Astralend contract.
type AstralendSetFeeIterator struct {
	Event *AstralendSetFee // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendSetFeeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendSetFee)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendSetFee)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendSetFeeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendSetFeeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendSetFee represents a SetFee event raised by the Astralend contract.
type AstralendSetFee struct {
	NewLendFee   *big.Int
	NewBorrowFee *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSetFee is a free log retrieval operation binding the contract event 0x032dc6a2d839eb179729a55633fdf1c41a1fc4739394154117005db2b354b9b5.
//
// Solidity: event SetFee(uint256 indexed newLendFee, uint256 indexed newBorrowFee)
func (_Astralend *AstralendFilterer) FilterSetFee(opts *bind.FilterOpts, newLendFee []*big.Int, newBorrowFee []*big.Int) (*AstralendSetFeeIterator, error) {

	var newLendFeeRule []interface{}
	for _, newLendFeeItem := range newLendFee {
		newLendFeeRule = append(newLendFeeRule, newLendFeeItem)
	}
	var newBorrowFeeRule []interface{}
	for _, newBorrowFeeItem := range newBorrowFee {
		newBorrowFeeRule = append(newBorrowFeeRule, newBorrowFeeItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "SetFee", newLendFeeRule, newBorrowFeeRule)
	if err != nil {
		return nil, err
	}
	return &AstralendSetFeeIterator{contract: _Astralend.contract, event: "SetFee", logs: logs, sub: sub}, nil
}

// WatchSetFee is a free log subscription operation binding the contract event 0x032dc6a2d839eb179729a55633fdf1c41a1fc4739394154117005db2b354b9b5.
//
// Solidity: event SetFee(uint256 indexed newLendFee, uint256 indexed newBorrowFee)
func (_Astralend *AstralendFilterer) WatchSetFee(opts *bind.WatchOpts, sink chan<- *AstralendSetFee, newLendFee []*big.Int, newBorrowFee []*big.Int) (event.Subscription, error) {

	var newLendFeeRule []interface{}
	for _, newLendFeeItem := range newLendFee {
		newLendFeeRule = append(newLendFeeRule, newLendFeeItem)
	}
	var newBorrowFeeRule []interface{}
	for _, newBorrowFeeItem := range newBorrowFee {
		newBorrowFeeRule = append(newBorrowFeeRule, newBorrowFeeItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "SetFee", newLendFeeRule, newBorrowFeeRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendSetFee)
				if err := _Astralend.contract.UnpackLog(event, "SetFee", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetFee is a log parse operation binding the contract event 0x032dc6a2d839eb179729a55633fdf1c41a1fc4739394154117005db2b354b9b5.
//
// Solidity: event SetFee(uint256 indexed newLendFee, uint256 indexed newBorrowFee)
func (_Astralend *AstralendFilterer) ParseSetFee(log types.Log) (*AstralendSetFee, error) {
	event := new(AstralendSetFee)
	if err := _Astralend.contract.UnpackLog(event, "SetFee", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendSetFeeAddressIterator is returned from FilterSetFeeAddress and is used to iterate over the raw logs and unpacked data for SetFeeAddress events raised by the Astralend contract.
type AstralendSetFeeAddressIterator struct {
	Event *AstralendSetFeeAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendSetFeeAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendSetFeeAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendSetFeeAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendSetFeeAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendSetFeeAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendSetFeeAddress represents a SetFeeAddress event raised by the Astralend contract.
type AstralendSetFeeAddress struct {
	OldFeeAddress common.Address
	NewFeeAddress common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterSetFeeAddress is a free log retrieval operation binding the contract event 0xd44190acf9d04bdb5d3a1aafff7e6dee8b40b93dfb8c5d3f0eea4b9f4539c3f7.
//
// Solidity: event SetFeeAddress(address indexed oldFeeAddress, address indexed newFeeAddress)
func (_Astralend *AstralendFilterer) FilterSetFeeAddress(opts *bind.FilterOpts, oldFeeAddress []common.Address, newFeeAddress []common.Address) (*AstralendSetFeeAddressIterator, error) {

	var oldFeeAddressRule []interface{}
	for _, oldFeeAddressItem := range oldFeeAddress {
		oldFeeAddressRule = append(oldFeeAddressRule, oldFeeAddressItem)
	}
	var newFeeAddressRule []interface{}
	for _, newFeeAddressItem := range newFeeAddress {
		newFeeAddressRule = append(newFeeAddressRule, newFeeAddressItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "SetFeeAddress", oldFeeAddressRule, newFeeAddressRule)
	if err != nil {
		return nil, err
	}
	return &AstralendSetFeeAddressIterator{contract: _Astralend.contract, event: "SetFeeAddress", logs: logs, sub: sub}, nil
}

// WatchSetFeeAddress is a free log subscription operation binding the contract event 0xd44190acf9d04bdb5d3a1aafff7e6dee8b40b93dfb8c5d3f0eea4b9f4539c3f7.
//
// Solidity: event SetFeeAddress(address indexed oldFeeAddress, address indexed newFeeAddress)
func (_Astralend *AstralendFilterer) WatchSetFeeAddress(opts *bind.WatchOpts, sink chan<- *AstralendSetFeeAddress, oldFeeAddress []common.Address, newFeeAddress []common.Address) (event.Subscription, error) {

	var oldFeeAddressRule []interface{}
	for _, oldFeeAddressItem := range oldFeeAddress {
		oldFeeAddressRule = append(oldFeeAddressRule, oldFeeAddressItem)
	}
	var newFeeAddressRule []interface{}
	for _, newFeeAddressItem := range newFeeAddress {
		newFeeAddressRule = append(newFeeAddressRule, newFeeAddressItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "SetFeeAddress", oldFeeAddressRule, newFeeAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendSetFeeAddress)
				if err := _Astralend.contract.UnpackLog(event, "SetFeeAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetFeeAddress is a log parse operation binding the contract event 0xd44190acf9d04bdb5d3a1aafff7e6dee8b40b93dfb8c5d3f0eea4b9f4539c3f7.
//
// Solidity: event SetFeeAddress(address indexed oldFeeAddress, address indexed newFeeAddress)
func (_Astralend *AstralendFilterer) ParseSetFeeAddress(log types.Log) (*AstralendSetFeeAddress, error) {
	event := new(AstralendSetFeeAddress)
	if err := _Astralend.contract.UnpackLog(event, "SetFeeAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendSetMinAmountIterator is returned from FilterSetMinAmount and is used to iterate over the raw logs and unpacked data for SetMinAmount events raised by the Astralend contract.
type AstralendSetMinAmountIterator struct {
	Event *AstralendSetMinAmount // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendSetMinAmountIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendSetMinAmount)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendSetMinAmount)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendSetMinAmountIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendSetMinAmountIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendSetMinAmount represents a SetMinAmount event raised by the Astralend contract.
type AstralendSetMinAmount struct {
	OldMinAmount *big.Int
	NewMinAmount *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSetMinAmount is a free log retrieval operation binding the contract event 0xfa6189b739625142c695478e9d0095a1cb9e6fad92ad8a727e0055a5cc85b06b.
//
// Solidity: event SetMinAmount(uint256 indexed oldMinAmount, uint256 indexed newMinAmount)
func (_Astralend *AstralendFilterer) FilterSetMinAmount(opts *bind.FilterOpts, oldMinAmount []*big.Int, newMinAmount []*big.Int) (*AstralendSetMinAmountIterator, error) {

	var oldMinAmountRule []interface{}
	for _, oldMinAmountItem := range oldMinAmount {
		oldMinAmountRule = append(oldMinAmountRule, oldMinAmountItem)
	}
	var newMinAmountRule []interface{}
	for _, newMinAmountItem := range newMinAmount {
		newMinAmountRule = append(newMinAmountRule, newMinAmountItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "SetMinAmount", oldMinAmountRule, newMinAmountRule)
	if err != nil {
		return nil, err
	}
	return &AstralendSetMinAmountIterator{contract: _Astralend.contract, event: "SetMinAmount", logs: logs, sub: sub}, nil
}

// WatchSetMinAmount is a free log subscription operation binding the contract event 0xfa6189b739625142c695478e9d0095a1cb9e6fad92ad8a727e0055a5cc85b06b.
//
// Solidity: event SetMinAmount(uint256 indexed oldMinAmount, uint256 indexed newMinAmount)
func (_Astralend *AstralendFilterer) WatchSetMinAmount(opts *bind.WatchOpts, sink chan<- *AstralendSetMinAmount, oldMinAmount []*big.Int, newMinAmount []*big.Int) (event.Subscription, error) {

	var oldMinAmountRule []interface{}
	for _, oldMinAmountItem := range oldMinAmount {
		oldMinAmountRule = append(oldMinAmountRule, oldMinAmountItem)
	}
	var newMinAmountRule []interface{}
	for _, newMinAmountItem := range newMinAmount {
		newMinAmountRule = append(newMinAmountRule, newMinAmountItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "SetMinAmount", oldMinAmountRule, newMinAmountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendSetMinAmount)
				if err := _Astralend.contract.UnpackLog(event, "SetMinAmount", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetMinAmount is a log parse operation binding the contract event 0xfa6189b739625142c695478e9d0095a1cb9e6fad92ad8a727e0055a5cc85b06b.
//
// Solidity: event SetMinAmount(uint256 indexed oldMinAmount, uint256 indexed newMinAmount)
func (_Astralend *AstralendFilterer) ParseSetMinAmount(log types.Log) (*AstralendSetMinAmount, error) {
	event := new(AstralendSetMinAmount)
	if err := _Astralend.contract.UnpackLog(event, "SetMinAmount", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendSetSwapRouterAddressIterator is returned from FilterSetSwapRouterAddress and is used to iterate over the raw logs and unpacked data for SetSwapRouterAddress events raised by the Astralend contract.
type AstralendSetSwapRouterAddressIterator struct {
	Event *AstralendSetSwapRouterAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendSetSwapRouterAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendSetSwapRouterAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendSetSwapRouterAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendSetSwapRouterAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendSetSwapRouterAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendSetSwapRouterAddress represents a SetSwapRouterAddress event raised by the Astralend contract.
type AstralendSetSwapRouterAddress struct {
	OldSwapAddress common.Address
	NewSwapAddress common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterSetSwapRouterAddress is a free log retrieval operation binding the contract event 0x4558149b3c5427365f76d4ff19bef30aba41f17e5e601d4661330d8d2b687627.
//
// Solidity: event SetSwapRouterAddress(address indexed oldSwapAddress, address indexed newSwapAddress)
func (_Astralend *AstralendFilterer) FilterSetSwapRouterAddress(opts *bind.FilterOpts, oldSwapAddress []common.Address, newSwapAddress []common.Address) (*AstralendSetSwapRouterAddressIterator, error) {

	var oldSwapAddressRule []interface{}
	for _, oldSwapAddressItem := range oldSwapAddress {
		oldSwapAddressRule = append(oldSwapAddressRule, oldSwapAddressItem)
	}
	var newSwapAddressRule []interface{}
	for _, newSwapAddressItem := range newSwapAddress {
		newSwapAddressRule = append(newSwapAddressRule, newSwapAddressItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "SetSwapRouterAddress", oldSwapAddressRule, newSwapAddressRule)
	if err != nil {
		return nil, err
	}
	return &AstralendSetSwapRouterAddressIterator{contract: _Astralend.contract, event: "SetSwapRouterAddress", logs: logs, sub: sub}, nil
}

// WatchSetSwapRouterAddress is a free log subscription operation binding the contract event 0x4558149b3c5427365f76d4ff19bef30aba41f17e5e601d4661330d8d2b687627.
//
// Solidity: event SetSwapRouterAddress(address indexed oldSwapAddress, address indexed newSwapAddress)
func (_Astralend *AstralendFilterer) WatchSetSwapRouterAddress(opts *bind.WatchOpts, sink chan<- *AstralendSetSwapRouterAddress, oldSwapAddress []common.Address, newSwapAddress []common.Address) (event.Subscription, error) {

	var oldSwapAddressRule []interface{}
	for _, oldSwapAddressItem := range oldSwapAddress {
		oldSwapAddressRule = append(oldSwapAddressRule, oldSwapAddressItem)
	}
	var newSwapAddressRule []interface{}
	for _, newSwapAddressItem := range newSwapAddress {
		newSwapAddressRule = append(newSwapAddressRule, newSwapAddressItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "SetSwapRouterAddress", oldSwapAddressRule, newSwapAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendSetSwapRouterAddress)
				if err := _Astralend.contract.UnpackLog(event, "SetSwapRouterAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetSwapRouterAddress is a log parse operation binding the contract event 0x4558149b3c5427365f76d4ff19bef30aba41f17e5e601d4661330d8d2b687627.
//
// Solidity: event SetSwapRouterAddress(address indexed oldSwapAddress, address indexed newSwapAddress)
func (_Astralend *AstralendFilterer) ParseSetSwapRouterAddress(log types.Log) (*AstralendSetSwapRouterAddress, error) {
	event := new(AstralendSetSwapRouterAddress)
	if err := _Astralend.contract.UnpackLog(event, "SetSwapRouterAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendStateChangeIterator is returned from FilterStateChange and is used to iterate over the raw logs and unpacked data for StateChange events raised by the Astralend contract.
type AstralendStateChangeIterator struct {
	Event *AstralendStateChange // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendStateChangeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendStateChange)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendStateChange)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendStateChangeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendStateChangeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendStateChange represents a StateChange event raised by the Astralend contract.
type AstralendStateChange struct {
	Pid         *big.Int
	BeforeState *big.Int
	AfterState  *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterStateChange is a free log retrieval operation binding the contract event 0x516112f3bf06e373fcea44db364769c04cc7ef4392e6de95d2b250720bcacefb.
//
// Solidity: event StateChange(uint256 indexed pid, uint256 indexed beforeState, uint256 indexed afterState)
func (_Astralend *AstralendFilterer) FilterStateChange(opts *bind.FilterOpts, pid []*big.Int, beforeState []*big.Int, afterState []*big.Int) (*AstralendStateChangeIterator, error) {

	var pidRule []interface{}
	for _, pidItem := range pid {
		pidRule = append(pidRule, pidItem)
	}
	var beforeStateRule []interface{}
	for _, beforeStateItem := range beforeState {
		beforeStateRule = append(beforeStateRule, beforeStateItem)
	}
	var afterStateRule []interface{}
	for _, afterStateItem := range afterState {
		afterStateRule = append(afterStateRule, afterStateItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "StateChange", pidRule, beforeStateRule, afterStateRule)
	if err != nil {
		return nil, err
	}
	return &AstralendStateChangeIterator{contract: _Astralend.contract, event: "StateChange", logs: logs, sub: sub}, nil
}

// WatchStateChange is a free log subscription operation binding the contract event 0x516112f3bf06e373fcea44db364769c04cc7ef4392e6de95d2b250720bcacefb.
//
// Solidity: event StateChange(uint256 indexed pid, uint256 indexed beforeState, uint256 indexed afterState)
func (_Astralend *AstralendFilterer) WatchStateChange(opts *bind.WatchOpts, sink chan<- *AstralendStateChange, pid []*big.Int, beforeState []*big.Int, afterState []*big.Int) (event.Subscription, error) {

	var pidRule []interface{}
	for _, pidItem := range pid {
		pidRule = append(pidRule, pidItem)
	}
	var beforeStateRule []interface{}
	for _, beforeStateItem := range beforeState {
		beforeStateRule = append(beforeStateRule, beforeStateItem)
	}
	var afterStateRule []interface{}
	for _, afterStateItem := range afterState {
		afterStateRule = append(afterStateRule, afterStateItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "StateChange", pidRule, beforeStateRule, afterStateRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendStateChange)
				if err := _Astralend.contract.UnpackLog(event, "StateChange", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStateChange is a log parse operation binding the contract event 0x516112f3bf06e373fcea44db364769c04cc7ef4392e6de95d2b250720bcacefb.
//
// Solidity: event StateChange(uint256 indexed pid, uint256 indexed beforeState, uint256 indexed afterState)
func (_Astralend *AstralendFilterer) ParseStateChange(log types.Log) (*AstralendStateChange, error) {
	event := new(AstralendStateChange)
	if err := _Astralend.contract.UnpackLog(event, "StateChange", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the Astralend contract.
type AstralendSwapIterator struct {
	Event *AstralendSwap // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendSwapIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendSwap)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendSwap)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendSwapIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendSwapIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendSwap represents a Swap event raised by the Astralend contract.
type AstralendSwap struct {
	FromCoin  common.Address
	ToCoin    common.Address
	FromValue *big.Int
	ToValue   *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSwap is a free log retrieval operation binding the contract event 0xfa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe235.
//
// Solidity: event Swap(address indexed fromCoin, address indexed toCoin, uint256 fromValue, uint256 toValue)
func (_Astralend *AstralendFilterer) FilterSwap(opts *bind.FilterOpts, fromCoin []common.Address, toCoin []common.Address) (*AstralendSwapIterator, error) {

	var fromCoinRule []interface{}
	for _, fromCoinItem := range fromCoin {
		fromCoinRule = append(fromCoinRule, fromCoinItem)
	}
	var toCoinRule []interface{}
	for _, toCoinItem := range toCoin {
		toCoinRule = append(toCoinRule, toCoinItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "Swap", fromCoinRule, toCoinRule)
	if err != nil {
		return nil, err
	}
	return &AstralendSwapIterator{contract: _Astralend.contract, event: "Swap", logs: logs, sub: sub}, nil
}

// WatchSwap is a free log subscription operation binding the contract event 0xfa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe235.
//
// Solidity: event Swap(address indexed fromCoin, address indexed toCoin, uint256 fromValue, uint256 toValue)
func (_Astralend *AstralendFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *AstralendSwap, fromCoin []common.Address, toCoin []common.Address) (event.Subscription, error) {

	var fromCoinRule []interface{}
	for _, fromCoinItem := range fromCoin {
		fromCoinRule = append(fromCoinRule, fromCoinItem)
	}
	var toCoinRule []interface{}
	for _, toCoinItem := range toCoin {
		toCoinRule = append(toCoinRule, toCoinItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "Swap", fromCoinRule, toCoinRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendSwap)
				if err := _Astralend.contract.UnpackLog(event, "Swap", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSwap is a log parse operation binding the contract event 0xfa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe235.
//
// Solidity: event Swap(address indexed fromCoin, address indexed toCoin, uint256 fromValue, uint256 toValue)
func (_Astralend *AstralendFilterer) ParseSwap(log types.Log) (*AstralendSwap, error) {
	event := new(AstralendSwap)
	if err := _Astralend.contract.UnpackLog(event, "Swap", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendWithdrawBorrowIterator is returned from FilterWithdrawBorrow and is used to iterate over the raw logs and unpacked data for WithdrawBorrow events raised by the Astralend contract.
type AstralendWithdrawBorrowIterator struct {
	Event *AstralendWithdrawBorrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendWithdrawBorrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendWithdrawBorrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendWithdrawBorrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendWithdrawBorrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendWithdrawBorrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendWithdrawBorrow represents a WithdrawBorrow event raised by the Astralend contract.
type AstralendWithdrawBorrow struct {
	From       common.Address
	Token      common.Address
	Amount     *big.Int
	BurnAmount *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterWithdrawBorrow is a free log retrieval operation binding the contract event 0x0f5e74952c2f9259a748f3aa9a6c4534a6f46a5966e5baabdb6bd337f05234a8.
//
// Solidity: event WithdrawBorrow(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) FilterWithdrawBorrow(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendWithdrawBorrowIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "WithdrawBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendWithdrawBorrowIterator{contract: _Astralend.contract, event: "WithdrawBorrow", logs: logs, sub: sub}, nil
}

// WatchWithdrawBorrow is a free log subscription operation binding the contract event 0x0f5e74952c2f9259a748f3aa9a6c4534a6f46a5966e5baabdb6bd337f05234a8.
//
// Solidity: event WithdrawBorrow(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) WatchWithdrawBorrow(opts *bind.WatchOpts, sink chan<- *AstralendWithdrawBorrow, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "WithdrawBorrow", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendWithdrawBorrow)
				if err := _Astralend.contract.UnpackLog(event, "WithdrawBorrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawBorrow is a log parse operation binding the contract event 0x0f5e74952c2f9259a748f3aa9a6c4534a6f46a5966e5baabdb6bd337f05234a8.
//
// Solidity: event WithdrawBorrow(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) ParseWithdrawBorrow(log types.Log) (*AstralendWithdrawBorrow, error) {
	event := new(AstralendWithdrawBorrow)
	if err := _Astralend.contract.UnpackLog(event, "WithdrawBorrow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AstralendWithdrawLendIterator is returned from FilterWithdrawLend and is used to iterate over the raw logs and unpacked data for WithdrawLend events raised by the Astralend contract.
type AstralendWithdrawLendIterator struct {
	Event *AstralendWithdrawLend // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AstralendWithdrawLendIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AstralendWithdrawLend)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AstralendWithdrawLend)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AstralendWithdrawLendIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AstralendWithdrawLendIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AstralendWithdrawLend represents a WithdrawLend event raised by the Astralend contract.
type AstralendWithdrawLend struct {
	From       common.Address
	Token      common.Address
	Amount     *big.Int
	BurnAmount *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterWithdrawLend is a free log retrieval operation binding the contract event 0x690f32ccf3e832d5ff975d781039bc2affebee9c973939c9b710091b87954c9d.
//
// Solidity: event WithdrawLend(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) FilterWithdrawLend(opts *bind.FilterOpts, from []common.Address, token []common.Address) (*AstralendWithdrawLendIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.FilterLogs(opts, "WithdrawLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return &AstralendWithdrawLendIterator{contract: _Astralend.contract, event: "WithdrawLend", logs: logs, sub: sub}, nil
}

// WatchWithdrawLend is a free log subscription operation binding the contract event 0x690f32ccf3e832d5ff975d781039bc2affebee9c973939c9b710091b87954c9d.
//
// Solidity: event WithdrawLend(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) WatchWithdrawLend(opts *bind.WatchOpts, sink chan<- *AstralendWithdrawLend, from []common.Address, token []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _Astralend.contract.WatchLogs(opts, "WithdrawLend", fromRule, tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AstralendWithdrawLend)
				if err := _Astralend.contract.UnpackLog(event, "WithdrawLend", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawLend is a log parse operation binding the contract event 0x690f32ccf3e832d5ff975d781039bc2affebee9c973939c9b710091b87954c9d.
//
// Solidity: event WithdrawLend(address indexed from, address indexed token, uint256 amount, uint256 burnAmount)
func (_Astralend *AstralendFilterer) ParseWithdrawLend(log types.Log) (*AstralendWithdrawLend, error) {
	event := new(AstralendWithdrawLend)
	if err := _Astralend.contract.UnpackLog(event, "WithdrawLend", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
